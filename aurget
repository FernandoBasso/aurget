#!/bin/bash
#
# pbrisbin 2012
#
###
info()  { echo -e "${colorB}:: ${colorW}$*${nocolor}";  }
warn()  { echo -e "${colorY}warning: ${colorW}$*${nocolor}" >&2; }
error() { echo -e "${colorR}error: ${colorW}$*${nocolor}"   >&2; }

prompt() {
  local ans

  read -p "$*? [Y/n] " ans

  case "${ans:-y}" in
    y|Y) return 0 ;;
    *)   return 1 ;;
  esac
}

# $1: string to encode
# echos url-encoded version
url_encode() {
  local string="$1" awkscript

  awkscript='
  $1 == "20"                    { printf("%s", "+"); next } # space becomes plus
  $1 ~  /0[adAD]/               {                    next } # strip newlines
  $2 ~  /^[a-zA-Z0-9.*()\/-]$/  { printf("%s", $2);  next } # pass through what we can
                                { printf("%%%s", $1)      } # take hex value of everything else
  '

  # thanks to Irm for this bit of magic
  hexdump -v -e '1/1 "%02x\t"' -e '1/1 "%_c\n"' <<< "$string" | LANG=C awk "$awkscript"
}

# $1: string
# $2: regex to match against it, OR
# $1: -F flag
# $2: string
# $3: non-regex to match against it
# returns 0 if matched
matches() {
  if [[ "$1" = '-F' ]]; then
    echo "$2" | grep -Fq -- "$3"
  else
    echo "$1" | grep -q -- "$2"
  fi
}

# $1: a json string
# $2: the single key you want the value for
# echos the value for that key
json_key() {
  local json="$1" key="$2"

  echo "$1" | sed -e '/.*"'"$2"'":"\([^"]*\)".*/!d; s//\1/g'
}

# $1: path to PKGBUILD
# $*: optional, reason for requiring edit
# returns 0 if OK to proceed
edit_pkgbuild() {
  local pkgbuild="$1"; shift
  local reason="${*:-sourcing for deps}"

  case "${edit_pkgbuilds:-prompt}" in
    never)  return 0 ;;
    prompt) prompt "Edit PKGBUILD before $reason" || return 0 ;;
  esac

  $EDITOR "$pkgbuild" || errorout 'problem editing PKGBUILD'
  prompt "Continue $reason"
}

# $1: name of package as downloaded
# returns 0 on successful source
# returns 1 on unavailable package
source_for_deps() {
  local pkgbuild="$tmpdir/${1}_PKGBUILD"
  local pkgbuild_url="$aur/packages/$(url_encode "${1:0:2}/$1")/PKGBUILD"

  if [[ -f "$pkgbuild" ]]; then
    # we've already seen this package, just return
    return 0
  fi

  if ! curl -f -s -o "$pkgbuild" "$pkgbuild_url"; then
    # not available in the AUR, assume it's available in the normal
    # repos for now. this will be checked later and the appropriate
    # error thrown.
    touch "$pkgbuild"
    return 1
  fi

  if prompt_to_edit "$pkgbuild" "sourcing $1 for dependencies"; then
    source "$pkgbuild"
    return 0
  fi

  return 1
}

# $1: url to taurball
# returns exit code from curl
download_or_extract() {
  local url="$1"

  if [[ "$sync_mode" = 'download' ]]; then
    curl -f -# -o "$target" "$(basename $url)"
  else
    curl -f -# "$url" | tar xvzf
  fi
}

# $1: name of package as downloaded
# returns exit code from makepkg
build_or_install() {
  local name="$1"

  pushd "$name" &>/dev/null

  if [[ -f "/etc/customizepkg.d/$name" ]]; then
    display 'Calling customizepkg...'
    customizepkg --modify || warn 'customizepkg had a problem'
  fi

  case "${sync_mode:-build}" in
    'build')   makepkg $makepkg_options    ;;
    'install') makepkg $makepkg_options -i ;;
  esac

  popd &>/dev/null
}


# echos a list of package names
#available_upgrades() {
  #while read -r name vers; do
    #versN="$(curl -f -s "${aur_info}$(url_encode "$name")" | sed -e '/.*"Version":"\([^"]*\)".*/!d; s//\1/g')"
    #[[ -n "$versN" ]] && [[ $(vercmp "$vers" -lt "$versN") ]] && echo "$name"
  #done < <(pacman -Qm)
#}

# {{{
#search_aur() {
  ## just print pkgbuild?
  #[[ "$search_mode" = 'print' ]] && print_pkgbuild "${args[@]}"

  ## continue with other searches
  #local awkscript results term Name Version Description URL URLPath OutOfDate

  #term="${args[*]}"

  #awkscript='
  #function unstring(str) {
    #sub(/[^:]+:/, "", str)
    #gsub(/\\\"/, "\"", str)
    #gsub(/"$/, "", str)
    #return substr(str, 2, length(str))
  #}

  #/Name":/        { printf "%s",    unstring($0) }
  #/Version":/     { printf "|%s",   unstring($0) }
  #/Description":/ { printf "|%s",   unstring($0) }
  #/URL":/         { printf "|%s",   unstring($0) }
  #/OutOfDate":/   { printf "|%s",   unstring($0) }
  #/URLPath":/     { printf "|%s\n", unstring($0) }
  #'

  ## parse JSON data
  #results="$(curl -fsS "${aur_srch}$(url_encode "$term")" | awk -F '[^\\\\]"' -v RS='{"|,"|"}' "$awkscript")"

  #[[ -z "$results" ]] && clean_exit 1

  #while IFS='|' read -r Name Version Description URL OutOfDate URLPath; do
    #[[ -z "$Name" ]] && continue
    #[[ "$search_mode" = 'info' ]] && [[ "$Name" != "$term" ]] && continue

    ## FYI: http://old.nabble.com/echo-interrupted-by-SIGCHLD-from-a-dying-coprocess-td28028050.html
    #case "$search_mode" in
      #quiet)  echo "$Name" 2>/dev/null ;;

      #info)   [[ "$OutOfDate" =~ ^(1|OutOfDate)$ ]] && outofdate="${colorR}Yes${nocolor}" || outofdate='No'
              #echo -e "${colorW}Repository \t: ${colorM}aur${nocolor}"              2>/dev/null
              #echo -e "${colorW}Name \t\t: $Name${nocolor}"                         2>/dev/null
              #echo -e "${colorW}Version \t: ${colorG}$Version${nocolor}"            2>/dev/null
              #echo -e "${colorW}URL \t\t: ${colorC}${URL//\\\///}${nocolor}"        2>/dev/null
              #echo -e "${colorW}Out of date \t: ${nocolor}$outofdate"               2>/dev/null
              #echo -e "${colorW}Description \t: ${nocolor}${Description//\\\///}\n" 2>/dev/null ;;

      #search) [[ "$OutOfDate" =~ ^(1|OutOfDate)$ ]] && outofdate="${colorR}[out of date]${nocolor}" || outofdate=''
              #echo -en "${colorM}aur/${colorW}$Name"  2>/dev/null
              #echo -en " ${colorG}$Version${nocolor}" 2>/dev/null
              #echo -e  " $outofdate"                  2>/dev/null
              #echo -e  "    ${Description//\\\///}"   2>/dev/null ;;

      #*)      errorout 'invalid search_mode'
    #esac
  #done < <(sort <<< "$results")
#}
# }}}

## dep_check {{{
#dep_check() {
  #echo 'resolving dependencies...'

  #local dep all_deps pac_deps
  #all_deps=(); aur_deps=(); pac_deps=(); mk_deps=()

  #while true; do
    #n=${#all_deps[@]}

    #for name in "${args[@]}" "${all_deps[@]}"; do
      ## keep args out of deps so error messages are more sane
      #if ! source_for_deps "$name"; then
        ## assume it's a pacman dep for now
        #grep -Fq -- " $name " <<< " ${args[@]} " || pac_deps+=("$name")
      #else
        #grep -Fq -- " $name " <<< " ${args[@]} " || aur_deps=("$name" "${aur_deps[@]}")

        ## filter satasfied deps, clear versioning
        #depends=($(pacman -T -- ${depends[@]} ${makedepends[@]}))
        #depends=("${depends[@]%>*}")
        #depends=("${depends[@]%=*}")
        #depends=("${depends[@]%<*}")

        ## store make depends for later removal
        #mk_deps+=("${makedepends[@]}")

        ## track unsatisfied deps
        #((${#depends[@]} > 0)) && all_deps+=("${depends[@]}")
      #fi
    #done

    ## if we found no more deps this round, we can stop
    #((${#all_deps[@]} == $n)) && break
  #done

  #if ((${#pac_deps[@]} > 0)); then
    ## check a list quickly for availability
    #while IFS=\' read -r _ dep _; do
      ## check only the error cases as a possible provides
      #pacman -Ssq -- "^$dep$" &>/dev/null || errorout "$dep: dependency cannot be met."
    #done < <(pacman -Si -- "${pac_deps[@]}" 2>&1 >/dev/null)

    ## sort and unique
    #pac_deps=($(sort -u <(printf '%s\n' "${pac_deps[@]}")))

    #echo; warn "the following (${#pac_deps[@]}) packages will be installed by pacman: ${pac_deps[@]}"; echo
  #fi
#}

## }}}

## add_targets_to_list {{{
#add_targets_to_list() {
  #local name dep Name Version URLPath

  ## are we adding these to be installed --asdeps?
  #dep="$1"; shift

  #for name in "$@"; do
    #if grep -Fq -- " $name " <<< " $ignore_packages "; then
      #if ! prompt "$name is in ignore_packages. Install anyway"; then
        #warn "skipping target: $name"
        #continue
      #fi
    #fi

    ## fetch JSON
    #read -r Name Version URLPath < <(curl -s "${aur_info}$(url_encode "$name")" | sed -e '/.*"Name":"\([^"]*\)".*"Version":"\([^"]*\)".*"URLPath":"\([^"]*\)".*/!d; s//\1 \2 \3/g')
    #[[ -z "$Name" ]] && errorout "$name: package not found in AUR."

    ## is it already up to date?
    #grep -Fqx -- "$Name $Version" "$tmpdir/installed.lst" && warn "$Name-$Version is up to date -- reinstalling"

    ## add non-dupes to list of targets
    #if ! grep -Fx -- " $Name " <<< " ${list_names[@]} "; then
      #list_names+=("$Name")
      #list_versions+=("$Version")
      #list_urls+=("$URLPath")
      #list_deps+=("$dep")
    #fi
  #done
#}

## }}}

## setup_targets {{{
#setup_targets() {
  #((${#args[@]} == 0)) && errorout 'no targets specified (use -h for help)'

  #$resolve_dependencies && dep_check

  #list_names=(); list_versions=(); list_urls=(); list_deps=()
  #pacman -Qm > "$tmpdir/installed.lst"

  #echo 'searching AUR...'
  #add_targets_to_list 1 "${aur_deps[@]}"
  #add_targets_to_list 0 "${args[@]}"

  #if ((${#list_names[@]} > 0)); then
    #echo -en "\n${colorY}Targets (${#list_names[@]}):${nocolor} "

    #for ((i=0; i<${#list_names[@]}; i++)); do
      #echo -n "${list_names[i]}-${list_versions[i]} "
    #done

    #prompt "\n\nProceed with installation" || clean_exit
    #process_targets
  #else
    #errorout 'no targets specified (use -h for help)'
  #fi
#}

## }}}

## process_targets {{{
#process_targets() {
  #Name=
  #Version=
  #URLPath=
  #dep=
  #pkg=

  #for ((i=0; i<${#list_names[@]}; i++)); do
    #Name="${list_names[i]}"
    #Version="${list_versions[i]}"
    #URLPath="${list_urls[i]}"
    #dep="${list_deps[i]}"

    ## check in the cache
    #pkg="$(find_pkg "$Name" "$Version")"

    #if ! $rebuild && [[ -n "$pkg" ]] && [[ "$sync_mode" = 'install' ]] && ! is_devel "$pkg"; then
      ## use cached package
      #display "Installing cached $pkg..."
    #else
      ## download from aur, sets $pkg variable
      #download_tarball "$Name" "$URLPath"
      #build_package "$dep" || continue
    #fi

    #install_package "$pkg" "$dep"
  #done

  ## remove make depends
  #if $remove_makedepends && ((${#mk_deps[@]} > 0)); then
    #display 'Removing make depends...'
    #for mk_dep in ${mk_deps[@]}; do
      #pacman --noconfirm -R $mk_dep || warn "unable to remove makedepend $mk_dep"
    #done
  #fi
#}

## }}}

aur='https://aur.archlinux.org'
aur_srch="$aur/rpc.php?type=search&arg="
aur_info="$aur/rpc.php?type=info&arg="
aur_pkgs="$aur/packages"

tmpdir="${TMPDIR:-/tmp}/aurget"
